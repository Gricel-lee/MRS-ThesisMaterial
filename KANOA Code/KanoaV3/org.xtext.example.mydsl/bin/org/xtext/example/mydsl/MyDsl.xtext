// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "http://www.example.org/dsl" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

ProblemSpecification returns ProblemSpecification:
	'ProblemSpecification'
	'{'
		'WorldModel' ':' worldModel+=WorldModel ( worldModel+=WorldModel)* 
		'TasksModel' ':' tasksModel+=TasksModel ( "," tasksModel+=TasksModel)*
		'RobotsModel' ':' robotsModel+=Robot ( "," robotsModel+=Robot)*
		'Mission' ':' mission+=Mission ( "," mission+=Mission)* 
	
	'}';

/// --------- World model
WorldModel returns WorldModel:
	Location | Paths;

Location returns Location:
	//{Location}
	name=EString ':'
	'('
		'x' x=EDouble
		'y' y=EDouble
		(',' 'describes' description=EString)?
	')';
Paths returns Paths:
	//{Paths}
	'distance'
		loc1=[Location|EString] 'to'
		loc2=[Location|EString]
		'is' distance=EDouble
		('has''success''rate:' success=EDouble '%')?
	;


/// --------- Tasks
TasksModel returns TasksModel:
	AtomicTask | CompoundTask;

AtomicTask returns AtomicTask:
	//{AtomicTask}
	name=EString ':'
	robots=EInt ('robots'|'robot') 'needed' 
	('at' 'location'
	loc=[Location|EString])?
	(',' retry=EInt 'retries''allowed')?
	
	;
CompoundTask returns CompoundTask:
	//{CompoundTask}
	name=EString ':'
	'subtasks'
	'['
		(canDoTask+=[TasksModel|EString] ( "," canDoTask+=[TasksModel|EString])* )?
	']'
	
	('constraint:' ordered?='ordered' | 'constraint:' consecutive?='consecutive')?
	;
	

/// ----------- Robots
	
Robot returns Robot:
	//{Robot}
	name=EString
	':'
		'at''initial''position' initLoc=[Location|EString]
		'has''velocity' velocity=EDouble
		'with''capabilities' 
		'('
			capabilities+=Capability ( "," capabilities+=Capability)*
		')'
	;

Capability returns Capability:
	//{Capability}
	at=[AtomicTask|EString] 
	'-required''time:' time=EDouble
	',''success''rate:' success=EDouble '%'
	;
	

/// ----------- Missions	

Mission returns Mission:
	missionTask+=MissionTask ( "," missionTask+=MissionTask)* 
	'objectives:'
		obj+=Objective ( "," obj+=Objective)*
		//objectives+=Objective ( "," objectives+=Objective)* ;	
	
	('constraints:'
		constraints+=Constraints ( "," constraints+=Constraints)*
	)?
	('parameters:'
		
		('time:' time = EInt )?
		('numAllocation:'numAlloc = EInt)?
		('population:' population = EInt)?
		('evaluation:' evaluations = EInt)?
	)?
	
	;	
	
MissionTask returns MissionTask:
	{MissionTask}
	name=EString ':'
	('atomic''task' at=[AtomicTask|EString] | 'compound''task' ct=[CompoundTask|EString])
	('at''location' loc=[Location|EString])?
	;

Constraints returns Constraints:
	RateSucc | SpaceXYRobot | TaskTime | AllocateT | Closest | MaxTasks  ;


RateSucc returns Constraints:
	{RateSucc}
	('rate''of''success''greater''than' rateSucc=EDouble)?
	;

SpaceXYRobot returns SpaceXYRobot:
	('robot' robot=[Robot|EString] | allrobots='all''robots' )
	'work''in' coordinate=XY
	lowerGreater=LowerGreater 'than' val=EDouble
	;
	
TaskTime returns TaskTime:
	('atomic''task' at=[AtomicTask|EString] |
	'compound''task' ct=[CompoundTask|EString] |
	'mission''task' mt=[MissionTask|EString])
	'has''to' startEnd=StartEnd
	'time:' time=EDouble	
	;

AllocateT returns AllocateT:
	'allocate'
	('atomic''task' at=[AtomicTask|EString] |
	'compound''task' ct=[CompoundTask|EString] |
	'mission''task' mt=[MissionTask|EString])
	'to'
	('robot' robot=[Robot|EString]| 'single''robot')
	;
Closest returns Closest:
	{Closest}
	'allocate'
		(all='all''tasks' |
		'atomic''task' at=[AtomicTask|EString] |
		'compound''task' ct=[CompoundTask|EString] |
		'mission''task' mt=[MissionTask|EString])
	'to''closest''robot'
	;
MaxTasks returns MaxTasks:
	'limit''max''number''of''tasks'
	(all='per''robot' | 'in''robot'robot=[Robot|EString])
	'to' num=EInt
	;






//objectives
enum Objective returns Objective:
				minIdle = 'minimiseIdle' | minTravel = 'minimiseTravel' | maxSucc = 'maximiseSuccess';

//others
enum XY returns XY:
				x = 'x' | y = 'y';

enum LowerGreater returns LowerGreater:
				lower = 'lower' | greater = 'greater';

enum StartEnd returns StartEnd:
				end = 'end before' | start = 'start after';
				//end = 'end' | start = 'start';

//types
EInt returns ecore::EInt:
	'-'? INT;

EBoolean returns ecore::EBoolean:
	'true' | 'false';
	
EString returns ecore::EString:
	STRING | ID;

EDouble returns ecore::EDouble:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;