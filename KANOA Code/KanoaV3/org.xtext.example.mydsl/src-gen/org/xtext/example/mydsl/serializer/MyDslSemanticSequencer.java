/*
 * generated by Xtext 2.30.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import dsl.AllocateT;
import dsl.AtomicTask;
import dsl.Capability;
import dsl.Closest;
import dsl.CompoundTask;
import dsl.DslPackage;
import dsl.Location;
import dsl.MaxTasks;
import dsl.Mission;
import dsl.MissionTask;
import dsl.Paths;
import dsl.ProblemSpecification;
import dsl.RateSucc;
import dsl.Robot;
import dsl.SpaceXYRobot;
import dsl.TaskTime;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.ALLOCATE_T:
				sequence_AllocateT(context, (AllocateT) semanticObject); 
				return; 
			case DslPackage.ATOMIC_TASK:
				sequence_AtomicTask(context, (AtomicTask) semanticObject); 
				return; 
			case DslPackage.CAPABILITY:
				sequence_Capability(context, (Capability) semanticObject); 
				return; 
			case DslPackage.CLOSEST:
				sequence_Closest(context, (Closest) semanticObject); 
				return; 
			case DslPackage.COMPOUND_TASK:
				sequence_CompoundTask(context, (CompoundTask) semanticObject); 
				return; 
			case DslPackage.LOCATION:
				sequence_Location(context, (Location) semanticObject); 
				return; 
			case DslPackage.MAX_TASKS:
				sequence_MaxTasks(context, (MaxTasks) semanticObject); 
				return; 
			case DslPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case DslPackage.MISSION_TASK:
				sequence_MissionTask(context, (MissionTask) semanticObject); 
				return; 
			case DslPackage.PATHS:
				sequence_Paths(context, (Paths) semanticObject); 
				return; 
			case DslPackage.PROBLEM_SPECIFICATION:
				sequence_ProblemSpecification(context, (ProblemSpecification) semanticObject); 
				return; 
			case DslPackage.RATE_SUCC:
				sequence_RateSucc(context, (RateSucc) semanticObject); 
				return; 
			case DslPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case DslPackage.SPACE_XY_ROBOT:
				sequence_SpaceXYRobot(context, (SpaceXYRobot) semanticObject); 
				return; 
			case DslPackage.TASK_TIME:
				sequence_TaskTime(context, (TaskTime) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraints returns AllocateT
	 *     AllocateT returns AllocateT
	 *
	 * Constraint:
	 *     ((at=[AtomicTask|EString] | ct=[CompoundTask|EString] | mt=[MissionTask|EString]) robot=[Robot|EString]?)
	 * </pre>
	 */
	protected void sequence_AllocateT(ISerializationContext context, AllocateT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TasksModel returns AtomicTask
	 *     AtomicTask returns AtomicTask
	 *
	 * Constraint:
	 *     (name=EString robots=EInt loc=[Location|EString]? retry=EInt?)
	 * </pre>
	 */
	protected void sequence_AtomicTask(ISerializationContext context, AtomicTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Capability returns Capability
	 *
	 * Constraint:
	 *     (at=[AtomicTask|EString] time=EDouble success=EDouble)
	 * </pre>
	 */
	protected void sequence_Capability(ISerializationContext context, Capability semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CAPABILITY__AT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CAPABILITY__AT));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CAPABILITY__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CAPABILITY__TIME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CAPABILITY__SUCCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CAPABILITY__SUCCESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCapabilityAccess().getAtAtomicTaskEStringParserRuleCall_0_0_1(), semanticObject.eGet(DslPackage.Literals.CAPABILITY__AT, false));
		feeder.accept(grammarAccess.getCapabilityAccess().getTimeEDoubleParserRuleCall_3_0(), semanticObject.getTime());
		feeder.accept(grammarAccess.getCapabilityAccess().getSuccessEDoubleParserRuleCall_7_0(), semanticObject.getSuccess());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraints returns Closest
	 *     Closest returns Closest
	 *
	 * Constraint:
	 *     (all='all' | at=[AtomicTask|EString] | ct=[CompoundTask|EString] | mt=[MissionTask|EString])
	 * </pre>
	 */
	protected void sequence_Closest(ISerializationContext context, Closest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TasksModel returns CompoundTask
	 *     CompoundTask returns CompoundTask
	 *
	 * Constraint:
	 *     (name=EString (canDoTask+=[TasksModel|EString] canDoTask+=[TasksModel|EString]*)? (ordered?='ordered' | consecutive?='consecutive')?)
	 * </pre>
	 */
	protected void sequence_CompoundTask(ISerializationContext context, CompoundTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorldModel returns Location
	 *     Location returns Location
	 *
	 * Constraint:
	 *     (name=EString x=EDouble y=EDouble description=EString?)
	 * </pre>
	 */
	protected void sequence_Location(ISerializationContext context, Location semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraints returns MaxTasks
	 *     MaxTasks returns MaxTasks
	 *
	 * Constraint:
	 *     ((all='per' | robot=[Robot|EString]) num=EInt)
	 * </pre>
	 */
	protected void sequence_MaxTasks(ISerializationContext context, MaxTasks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MissionTask returns MissionTask
	 *
	 * Constraint:
	 *     (name=EString (at=[AtomicTask|EString] | ct=[CompoundTask|EString]) loc=[Location|EString]?)
	 * </pre>
	 */
	protected void sequence_MissionTask(ISerializationContext context, MissionTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     (
	 *         missionTask+=MissionTask 
	 *         missionTask+=MissionTask* 
	 *         obj+=Objective 
	 *         obj+=Objective* 
	 *         (constraints+=Constraints constraints+=Constraints*)? 
	 *         time=EInt? 
	 *         numAlloc=EInt? 
	 *         population=EInt? 
	 *         evaluations=EInt?
	 *     )
	 * </pre>
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorldModel returns Paths
	 *     Paths returns Paths
	 *
	 * Constraint:
	 *     (loc1=[Location|EString] loc2=[Location|EString] distance=EDouble success=EDouble?)
	 * </pre>
	 */
	protected void sequence_Paths(ISerializationContext context, Paths semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProblemSpecification returns ProblemSpecification
	 *
	 * Constraint:
	 *     (
	 *         worldModel+=WorldModel 
	 *         worldModel+=WorldModel* 
	 *         tasksModel+=TasksModel 
	 *         tasksModel+=TasksModel* 
	 *         robotsModel+=Robot 
	 *         robotsModel+=Robot* 
	 *         mission+=Mission 
	 *         mission+=Mission*
	 *     )
	 * </pre>
	 */
	protected void sequence_ProblemSpecification(ISerializationContext context, ProblemSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraints returns RateSucc
	 *     RateSucc returns RateSucc
	 *
	 * Constraint:
	 *     rateSucc=EDouble?
	 * </pre>
	 */
	protected void sequence_RateSucc(ISerializationContext context, RateSucc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (name=EString initLoc=[Location|EString] velocity=EDouble capabilities+=Capability capabilities+=Capability*)
	 * </pre>
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraints returns SpaceXYRobot
	 *     SpaceXYRobot returns SpaceXYRobot
	 *
	 * Constraint:
	 *     ((robot=[Robot|EString] | allrobots='all') coordinate=XY lowerGreater=LowerGreater val=EDouble)
	 * </pre>
	 */
	protected void sequence_SpaceXYRobot(ISerializationContext context, SpaceXYRobot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraints returns TaskTime
	 *     TaskTime returns TaskTime
	 *
	 * Constraint:
	 *     ((at=[AtomicTask|EString] | ct=[CompoundTask|EString] | mt=[MissionTask|EString]) startEnd=StartEnd time=EDouble)
	 * </pre>
	 */
	protected void sequence_TaskTime(ISerializationContext context, TaskTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
